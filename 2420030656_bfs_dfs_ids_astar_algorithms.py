# -*- coding: utf-8 -*-
"""2420030656_BFS_DFS_IDS_ASTAR_algorithms.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TLPfm7VBvyhSdHwbJgEvl31hkZ5zMjSO
"""

#BFS PATH
graph = {
    '5': ['3', '7'],
    '3': ['2', '4'],
    '7': ['8'],
    '2': [],
    '4': ['8'],
    '8': []
}

def bfs_path(graph, start, goal):
    visited = [start]
    queue = [[start]]

    while queue:
        path = queue.pop(0)
        node = path[-1]

        if node == goal:
            return path

        for neighbour in graph[node]:
            if neighbour not in visited:
                visited.append(neighbour)
                new_path = list(path)
                new_path.append(neighbour)
                queue.append(new_path)

    return None

print("Path from 5 to 8:", bfs_path(graph, '5', '8'))

#DFS PATH
def dfs_path(graph, start, goal):
    visited = set()
    stack = [[start]]  # Stack of paths, each path is a list of nodes

    while stack:
        path = stack.pop()  # Pop the last path (LIFO)
        node = path[-1]  # Get the last node in the path

        if node == goal:
            return path

        if node not in visited:
            visited.add(node)
            for neighbour in graph[node]:
                if neighbour not in visited:
                    new_path = list(path)
                    new_path.append(neighbour)
                    stack.append(new_path)

    return None

# Test DFS
graph = {
    '5': ['3', '7'],
    '3': ['2', '4'],
    '7': ['8'],
    '2': [],
    '4': ['8'],
    '8': []
}
print("DFS Path from 5 to 8:", dfs_path(graph, '5', '8'))

#Iterative Deepening Search (IDS)
def dfs_limited(graph, node, goal, depth, path, visited):
    if depth < 0:
        return None
    if node == goal:
        return path

    visited.add(node)
    for neighbour in graph[node]:
        if neighbour not in visited:
            result = dfs_limited(graph, neighbour, goal, depth - 1, path + [neighbour], visited.copy())
            if result:
                return result
    return None

def ids_path(graph, start, goal):
    depth = 0
    while True:
        result = dfs_limited(graph, start, goal, depth, [start], set())
        if result:
            return result
        depth += 1
        if depth > len(graph):  # Prevent infinite loops in disconnected graphs
            return None

# Test IDS
print("IDS Path from 5 to 8:", ids_path(graph, '5', '8'))

#A* Algorithm
from heapq import heappush, heappop

def a_star_path(graph, start, goal):

    def heuristic(node, goal):
        return 0

    queue = [(0, [start])]
    visited = set()
    g_scores = {start: 0}

    while queue:
        f_score, path = heappop(queue)
        node = path[-1]

        if node == goal:
            return path

        if node not in visited:
            visited.add(node)
            for neighbour in graph[node]:
                if neighbour not in visited:
                    g_score = g_scores[node] + 1
                    if neighbour not in g_scores or g_score < g_scores[neighbour]:
                        g_scores[neighbour] = g_score
                        f_score = g_score + heuristic(neighbour, goal)
                        new_path = path + [neighbour]
                        heappush(queue, (f_score, new_path))

    return None


print("A* Path from 5 to 8:", a_star_path(graph, '5', '8'))